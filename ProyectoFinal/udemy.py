# -*- coding: utf-8 -*-
"""Udemy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vu3Z3JSMqtUU8G93i4ggbSvGpEFaoNmS
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statistics
import scipy.stats as stats

df= pd.read_csv('/content/udemy_courses_dataset.csv')
df.head()

df.info()

#Nos centraremos en al columna precios de los cursos

df.rename(columns={'price':'X'}, inplace=True)
df.columns

Tabla_Frecuencia=pd.DataFrame()
#X son nuestros precios de los cursos

#Frecuencia absoluta es la cantidad de veces que se repite nuestros precios (X).
Tabla_Frecuencia["Frecuencia_absolutas"]=df["X"].value_counts().sort_index()


#Acumulada absoluta es la suma de la frecuencia absoluta que se va acumulando.
Tabla_Frecuencia['Acumulada_Absoluta']=Tabla_Frecuencia["Frecuencia_absolutas"].cumsum()

RecoleccionFrecuencia =Tabla_Frecuencia["Frecuencia_absolutas"].cumsum()

#Frecuencia Relativa es la suma del total de los precios (X) dividido la acumulada Absoluta
Tabla_Frecuencia["Frecuencia_Relativa"]=df["X"].value_counts(normalize=True)

#Acumulada relativa es la suma de las frecuencias relativas que se van acumulando.
Tabla_Frecuencia["Acumulada_Relativa"]=Tabla_Frecuencia["Frecuencia_Relativa"].cumsum()

Tabla_Frecuencia

#Calculo de media
Media= df["X"].mean()
print("MEDIA:",Media)

#Calculo de moda
moda= df["X"].mode()[0]
print("MODA:",moda)

#Calculo de Mediana
Mediana= df["X"].median()
print("MEDIANA:",Mediana)

#Calculo de medida de dispersion
#Rango
Rango=df["X"].max()-df['X'].min()
print("Rango:", Rango)

#Varianza
suma_cuadrada = sum((df["X"] - Media)**2)
n = len(df["X"])
varianza_muestral = suma_cuadrada/(n-1)
print("Varianza muestral:",varianza_muestral)

#Desvio estandar
Desvio_Estandar=statistics.stdev(df['X'])
print("DESVIO ESTANDAR:",Desvio_Estandar)

#GRAFICOS
print(f"""
1er cuartil: {np.quantile(df["X"],0.25)}
2do cuartil: {np.quantile(df["X"],0.50)}
3er cuartil: {np.quantile(df["X"],0.75)}
""")

#Histograma

histograma = sns.histplot(df['X'], bins=[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180, 185, 190, 195, 200])

#Poligono de Frecuencia
# poligono = plt.plot(df['X'])

valores_completos = range(df['X'].min(), df['X'].max() + 1)
frecuencia_absoluta_grafico = df['X'].value_counts().reindex(valores_completos, fill_value=0)
plt.figure(figsize=(12, 6))
plt.plot(frecuencia_absoluta_grafico.index, frecuencia_absoluta_grafico.values, 'bo-', label='Frecuencia Absoluta')
plt.title('Frecuencia Absoluta de Precios de Cursos', fontsize=16)
plt.xlabel('Precio ($)', fontsize=14)
plt.ylabel('Frecuencia Absoluta', fontsize=14)
plt.legend(fontsize=12)
plt.grid(alpha=0.5)
plt.show()

#Grafico de caja

df['X'].plot.box()

df['X'].plot.kde()

frecuencia_acumulada = frecuencia_absoluta_grafico.cumsum()

# Graficar la ojiva
plt.figure(figsize=(12, 6))
plt.plot(frecuencia_acumulada.index, frecuencia_acumulada.values, 'r^-', label='Frecuencia Acumulada')
plt.title('Ojiva de Frecuencia Acumulada de Precios de Cursos', fontsize=16)
plt.xlabel('Precio ($)', fontsize=14)
plt.ylabel('Frecuencia Acumulada', fontsize=14)
plt.legend(fontsize=12)
plt.grid(alpha=0.5)
plt.show()

# Identificar el estadístico muestra (media, desvío estándar, proporción)

# Media muestral
media_muestral = df["X"].mean()
print("Media muestral:", media_muestral)

# Desviación estándar muestral
desviacion_estandar_muestral = df["X"].std()
print("Desviación estándar muestral:", desviacion_estandar_muestral)

# Proporción (si aplica, por ejemplo, la proporción de cursos con precio mayor a $50)
proporcion_mayor_50 = (df["X"] > 50).mean()
print("Proporción de cursos con precio mayor a $50:", proporcion_mayor_50)

# Calcular el intervalo de confianza para los estadísticos muestrales.

# Intervalo de confianza para la media
n = len(df["X"])  # Tamaño de la muestra
confidence_level = 0.95  # Nivel de confianza deseado (por ejemplo, 95%)
degrees_of_freedom = n - 1  # Grados de libertad
standard_error = desviacion_estandar_muestral / np.sqrt(n)  # Error estándar
t_critical = stats.t.ppf((1 + confidence_level) / 2, degrees_of_freedom)  # Valor crítico t
margin_of_error = t_critical * standard_error  # Margen de error

confidence_interval_mean = (media_muestral - margin_of_error, media_muestral + margin_of_error)
print("Intervalo de confianza para la media:", confidence_interval_mean)


# Intervalo de confianza para la desviación estándar (usando chi-cuadrado)
alpha = 1 - confidence_level  # Nivel de significancia
chi_squared_lower = stats.chi2.ppf(1 - alpha / 2, degrees_of_freedom)  # Valor crítico chi-cuadrado inferior
chi_squared_upper = stats.chi2.ppf(alpha / 2, degrees_of_freedom)  # Valor crítico chi-cuadrado superior

confidence_interval_std = (
    np.sqrt(((n - 1) * desviacion_estandar_muestral**2) / chi_squared_lower),
    np.sqrt(((n - 1) * desviacion_estandar_muestral**2) / chi_squared_upper),
)
print("Intervalo de confianza para la desviación estándar:", confidence_interval_std)


# Intervalo de confianza para la proporción (si aplica)
# Si se calcula la proporción, se puede usar la fórmula de la proporción muestral y el error estándar
# para calcular el intervalo de confianza usando la distribución normal.
# Se pueden usar las funciones stats.norm.ppf() y stats.norm.cdf() para obtener el valor crítico Z
# y la probabilidad acumulada, respectivamente.

#Estimar el error estándar (z,t o h)

# Error estándar para la media
standard_error_mean = desviacion_estandar_muestral / np.sqrt(n)
print("Error estándar para la media:", standard_error_mean)

# Error estándar para la proporción (si aplica)
# Si se calcula la proporción, se puede usar la fórmula del error estándar de la proporción.
# Por ejemplo:
# standard_error_proportion = np.sqrt((proporcion_mayor_50 * (1 - proporcion_mayor_50)) / n)


# Elegir el error estándar adecuado (z, t o h) depende de la situación.
# - z: se usa para la media de la población con desviación estándar conocida (o con muestra grande)
# - t: se usa para la media de la población con desviación estándar desconocida (o con muestra pequeña)
# - h: se usa para la proporción de la población

# En este caso, dado que la desviación estándar de la población es desconocida y estamos trabajando con la media muestral, debemos usar el error estándar t.
# El error estándar t ya se calculó como "standard_error_mean" en el código anterior.

# Utilizar la distribución adecuada, según el tamaño de la muestra


n = len(df["X"])

# Elegir la distribución adecuada
if n >= 30:
    # Si el tamaño de la muestra es mayor o igual a 30, se puede usar la distribución normal
    print("Usando la distribución normal para la media.")

    # Calcular el intervalo de confianza para la media
    confidence_level = 0.95
    z_critical = stats.norm.ppf((1 + confidence_level) / 2)
    margin_of_error = z_critical * (desviacion_estandar_muestral / np.sqrt(n))
    confidence_interval_mean = (media_muestral - margin_of_error, media_muestral + margin_of_error)
    print("Intervalo de confianza para la media:", confidence_interval_mean)

else:
    # Si el tamaño de la muestra es menor a 30, se usa la distribución t de Student
    print("Usando la distribución t de Student para la media.")

    # Calcular el intervalo de confianza para la media
    confidence_level = 0.95
    degrees_of_freedom = n - 1
    t_critical = stats.t.ppf((1 + confidence_level) / 2, degrees_of_freedom)
    margin_of_error = t_critical * (desviacion_estandar_muestral / np.sqrt(n))
    confidence_interval_mean = (media_muestral - margin_of_error, media_muestral + margin_of_error)
    print("Intervalo de confianza para la media:", confidence_interval_mean)


# Podemos también calcular intervalos de confianza para la desviación estándar usando la distribución chi-cuadrado
# o para proporciones usando la distribución normal.

#Calcular el valor del parámetro poblacional

# Calcular el intervalo de confianza para la media poblacional
confidence_level = 0.95  # Nivel de confianza deseado (por ejemplo, 95%)
n = len(df["X"])  # Tamaño de la muestra
degrees_of_freedom = n - 1  # Grados de libertad
standard_error = desviacion_estandar_muestral / np.sqrt(n)  # Error estándar

if n >= 30:
  # Si el tamaño de la muestra es grande (n >= 30), se puede usar la distribución normal
  z_critical = stats.norm.ppf((1 + confidence_level) / 2)  # Valor crítico Z
  margin_of_error = z_critical * standard_error  # Margen de error
  confidence_interval_mean = (media_muestral - margin_of_error, media_muestral + margin_of_error)
  print("Intervalo de confianza para la media (usando Z):", confidence_interval_mean)
else:
  # Si el tamaño de la muestra es pequeño (n < 30), se debe usar la distribución t de Student
  t_critical = stats.t.ppf((1 + confidence_level) / 2, degrees_of_freedom)  # Valor crítico t
  margin_of_error = t_critical * standard_error  # Margen de error
  confidence_interval_mean = (media_muestral - margin_of_error, media_muestral + margin_of_error)
  print("Intervalo de confianza para la media (usando t):", confidence_interval_mean)